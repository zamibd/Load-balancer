#===============================================================================
# HAProxy Configuration for DNS over TLS (DoT) with Tenant Validation
# Production-Ready Configuration with Security Hardening
# Domain: *.dns.routedns.io
#===============================================================================

#-------------------------------------------------------------------------------
# GLOBAL SETTINGS
#-------------------------------------------------------------------------------
global
    # Logging - stdout for Docker
    log stdout format raw local0 info
    log stdout format raw local1 notice
    
    # Process settings - let HAProxy auto-detect threads based on available CPUs
    maxconn 30000
    # nbthread removed - HAProxy will auto-detect based on available CPUs
    
    # HAProxy 3.3+ optimizations
    tune.stick-counters 12
    tune.pattern.cache-size 1000000
    tune.vars.global-max-size 1048576
    
    # Lua settings - must be set before lua-load (HAProxy 3.3+)
    tune.lua.bool-sample-conversion normal
    
    # Load Lua script for tenant validation
    lua-load /usr/local/etc/haproxy/lua/tenant_validation.lua
    
    # SSL/TLS settings - Enhanced for HAProxy 3.3
    ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305
    ssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256
    ssl-default-bind-options ssl-min-ver TLSv1.2 no-tls-tickets prefer-client-ciphers
    
    ssl-default-server-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305
    ssl-default-server-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256
    ssl-default-server-options ssl-min-ver TLSv1.2 no-tls-tickets
    
    # Enhanced tuning for HAProxy 3.3
    tune.ssl.default-dh-param 2048
    tune.bufsize 16384
    tune.ssl.cachesize 100000
    tune.ssl.lifetime 300
    tune.ssl.maxrecord 16384
    ocsp-update.mode on
    
    # Stats socket for runtime management
    stats socket /var/run/haproxy/admin.sock mode 660 level admin expose-fd listeners
    stats timeout 30s

#-------------------------------------------------------------------------------
# DEFAULT SETTINGS
#-------------------------------------------------------------------------------
defaults
    log     global
    mode    tcp
    option  tcplog
    option  dontlognull
    option  log-health-checks
    
    # Timeouts appropriate for DoT
    timeout connect 5s
    timeout client  30s
    timeout server  30s
    timeout tunnel  60s
    
    # Retry settings
    retries 3
    option redispatch
    
    # Error handling
    default-server inter 3s fall 3 rise 2

#-------------------------------------------------------------------------------
# STICK TABLES FOR RATE LIMITING AND DDOS MITIGATION
#-------------------------------------------------------------------------------

# Table: Track connections per source IP (IPv4 and IPv6)
backend st_src_conn_rate
    stick-table type ipv6 size 1m expire 10m store conn_rate(10s),conn_cur,gpc0,gpc1

# Table: Track tenant code usage
backend st_tenant_rate
    stick-table type string len 64 size 500k expire 30m store conn_rate(10s),conn_cur,gpc0

# Table: Banned IPs (temporary bans for 30 minutes)
backend st_banned_ips
    stick-table type ipv6 size 100k expire 30m store gpc0

#-------------------------------------------------------------------------------
# FRONTEND: DNS over TLS (DoT) - Port 853
#-------------------------------------------------------------------------------
frontend ft_dot
    bind *:853 ssl crt /usr/local/etc/haproxy/certs/dot.pem alpn dot
    
    mode tcp
    option tcplog
    
    # Production log format with block reason
    log-format "%ci:%cp [%t] %ft %b/%s %Tw/%Tc/%Tt %B %ts %ac/%fc/%bc/%sc/%rc %sq/%bq sni:%[ssl_fc_sni] tenant:%[var(txn.tenant_code)] valid:%[var(txn.tenant_valid)] reason:%[var(txn.block_reason)]"
    
    #---------------------------------------------------------------------------
    # PHASE 1: CONNECTION-LEVEL DDOS MITIGATION
    #---------------------------------------------------------------------------
    
    # Track source IP
    tcp-request connection track-sc0 src table st_src_conn_rate
    
    # Reject banned IPs immediately
    tcp-request connection reject if { src,table_gpc0(st_banned_ips) gt 0 }
    
    # Rate limit: Max 20 new connections per 10 seconds per IP
    tcp-request connection reject if { sc0_conn_rate(st_src_conn_rate) gt 20 }
    
    # Concurrent connection limit: Max 10 simultaneous connections per IP
    tcp-request connection reject if { sc0_conn_cur(st_src_conn_rate) gt 10 }
    
    # Auto-ban: Flag IPs with excessive connection rates (>50/10s)
    tcp-request connection sc-inc-gpc0(0) if { sc0_conn_rate(st_src_conn_rate) gt 50 }
    
    # Move flagged IPs to ban table after 3 violations
    tcp-request connection track-sc1 src table st_banned_ips if { sc_get_gpc0(0) gt 3 }
    tcp-request connection sc-inc-gpc0(1) if { sc_get_gpc0(0) gt 3 }
    
    #---------------------------------------------------------------------------
    # PHASE 2: TLS HANDSHAKE - Extract tenant from SNI
    #---------------------------------------------------------------------------
    
    # Wait for TLS ClientHello
    tcp-request inspect-delay 5s
    
    # Extract tenant code from SNI: {tenant}.dns.routedns.io â†’ tenant
    tcp-request content set-var(txn.sni) ssl_fc_sni
    tcp-request content set-var(txn.tenant_code) ssl_fc_sni,field(1,.)
    
    #---------------------------------------------------------------------------
    # PHASE 3: TENANT VALIDATION VIA API (Lua)
    #---------------------------------------------------------------------------
    
    # Call Lua to validate tenant against routedns.io database
    tcp-request content lua.validate_tenant
    
    # Reject if tenant validation failed
    tcp-request content reject if !{ var(txn.tenant_valid) -m int 1 }
    
    #---------------------------------------------------------------------------
    # PHASE 4: TENANT RATE LIMITING
    #---------------------------------------------------------------------------
    
    # Track per-tenant request rate
    tcp-request content track-sc2 var(txn.tenant_code) table st_tenant_rate if { var(txn.tenant_code) -m found }
    
    # Tenant rate limit: Max 100 connections per 10 seconds per tenant
    tcp-request content reject if { sc2_conn_rate(st_tenant_rate) gt 100 }
    
    #---------------------------------------------------------------------------
    # PHASE 5: PAYLOAD SIZE VALIDATION
    #---------------------------------------------------------------------------
    
    # DNS max payload: 4KB (conservative limit for DoT)
    tcp-request content reject if { req.len gt 4096 }
    
    # Accept valid requests
    tcp-request content accept
    
    # Route to upstream DNS servers
    default_backend bk_dot_upstream

#-------------------------------------------------------------------------------
# FRONTEND: Health Check and Stats
#-------------------------------------------------------------------------------
frontend ft_stats
    bind *:8404
    mode http
    
    # Basic auth for stats (change password in production)
    acl auth_ok http_auth(stats_users)
    http-request auth realm HAProxy-Stats unless auth_ok || { path /health } || { path /metrics }
    
    stats enable
    stats uri /stats
    stats refresh 10s
    stats show-legends
    stats show-node
    
    # Prometheus metrics endpoint (native HAProxy 2.0+ format)
    http-request use-service prometheus-exporter if { path /metrics }
    
    # Health check endpoint (no auth required)
    monitor-uri /health

# Stats users - credentials loaded from environment via entrypoint script
userlist stats_users
    user imzami password $5$saltsalt$H..3oBcIbZUCyOQJTtZ9B57TdN8Y/GXRRtBLGcG74R3

#-------------------------------------------------------------------------------
# BACKEND: DoT Upstream Servers
#-------------------------------------------------------------------------------
backend bk_dot_upstream
    mode tcp
    balance leastconn
    
    # Session persistence by source IP
    stick-table type ipv6 size 100k expire 5m
    stick on src
    
    # Simple TCP health check
    option tcp-check
    tcp-check connect
    
    # Single upstream DNS server (RouteDNS) - using Docker service name
    server routedns routedns:5301 check inter 10s fall 3 rise 2
